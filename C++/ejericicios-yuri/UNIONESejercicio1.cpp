/*LA UNION ES UN TIPO DE DATO DERIVADO CUYOS MIEMBROS 
COMPARTEN EL MISMO ESPACIO DE ALMACENAMIENTO. PARA CIERTAS SITUACIONES
ALGUNAS VARIABLES PUDIERAN SER DE NO IMPORTANCIA PERO OTRAS VARIABLES LO SON
POR LO QUE LAUNION COMPARTE EL ESPACIO, EN VEZ DE DESPERDICIAR ALMACENAMIENTO
EN VARIABLES QUE NO ESTAN SIENDO UTILIZADAS. LOS MIEMBROS DE LA UNION PUEDEN
SER DE CUALQUIER TIPO. EL NUMERO DE BYTES UTILIZADOS PARA ALMACENAR UNA UNION 
DEBEN SER POR LO MENOS SUFICIENTES PARA CONTENER EL MIEMBRO MAS GRANDE.

SE DECLARA CON LA PALABRA RESERVADA union EN EL MISMO
FORMATO QUE LA ESTRUCTURA 

    union number  {
      int x;
      float y;  
    };

INDICA QUE number ES UN TIPO UNION CON MIEMBROS int x y float y
EN UN PROGRAMA NORMALMENTE LA DEFINICION DE UNION ANTECEDE AL MAIN,
POR LO QUE PUEDE SER UTILIZADA PARA DECLARAR VARIABLES EN TODAS 
LAS FUNCIONES DEL PROGRAMA

LAS OPERACIONESQUE PUEDEN SER EJECUTADAS EN UNA UNION SON: ASIGNAR
UNA UNION A OTRA UNION DEL MISMO TIPO, Y TENER ACCESO A LOS MIEMBROS
DE UNA UNION UTILIZANDOEL OPERADOR DE MIEMBRO DE ESTRUCTURA Y EL APUNTADOR
DE ESTRUCTURA, LAS UNIONES NO PUEDEN COMPARARSE ENTRE SI, POR LAS MISMAS
RAZONES QUE NO PUEDEN COMPARARSE A LAS ESTRUCTURAS

EN UNA DECLARACION, UNA UNION PUEDE SER INICIALIZADA UNICAMENTE CON EL 
VALOR DEL MISMO TIPO QUE EL PRIMER MIEMBRO DE LA UNION . POR EJEMPLO,
EN LA UNION ANTERIOR, LA DECLARACION 
            union number value {10};
ES UNA UNICIALIZACION VALIDA DE LA VARIABLE  DE UNION value
, POR QUE LA UNION ESTA INICIALIZADA CON INT PERO LA SIGUIENTE DECLARACION
NO SERIA VALIDA YA QUE SOLO ES AL PRIMER MIEMBRO
            union number value {1.49};


/******LAS UNIONES SON UTILICES CUANDO QUEREMOS CONSERVAR LA MEMORIA CUANDO
 * ES LIMITADA
 * LAS UNIONES NO PUEDEN ALMACENAR REFERENCIAS Y NO SOPORTAN HERENCIA
 * LOS ELEMENTOS DE LA UNION SON PUBLICOS POR DEFECTO
*/

#include <iostream>

union coleccion
{
    int num;
    char  ch;
    bool st;
};

int main(void)
{

    std::cout << sizeof(coleccion) ;

    coleccion jr = {5};
    std::cout << jr.num;

    jr.st = false;
    std::cout << jr.st;

    //APARTIR DE LA SEGUNDA OPCION LA VARIABLE BOOLEANA
    //OCUPA EL ESPACIO DE MEMORIA Y LA INFORMACION QUE HABIA EN NUM 
    //SE HA PERDIDO
}